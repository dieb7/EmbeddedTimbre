// Copyright TimbreWorks Engineering 1990-2009
/* Source file generated by Timbre */
// modified Oct 21, 2014

#include "botkernl.h"  /* interface to VFM */
#include "printers.h"
#include <stdio.h>
/* Example of some float functions for Timbre  Rob Chapman  Feb 23, 1995 */
#include <math.h>
#define isFloat *(float *)&

void F_DOT();
void F_DOT()
{
	char fs[100], *fsp=&fs[0];

	sprintf(fsp," %f ",*(float *)sp++); // never prints exponents; always n.mmmmmm
	while (*fsp)
		printChar((Byte)*fsp++);
		
// doesn't handle nan, large or small numbers; but it saves 8K and doesn't need stdio.h
// i.e. 1000000000 i>f dup f* f. -1.-1-1-1-1-1-1
// 	float f = *(float *)sp++;
// 	Long i;
// 	Long n = 7;
// 
// 	if (f < 0) {
// 		printChar('-');
// 		f = (float)fabs(f);
// 	}
// 	while(n--) {
// 		i = (Long)f;
// 		f = 10*(f - (float)i);
// 		printDec0(i);
// 		if (n == 6) printChar('.');
// 		if (f == 0.0) return;
// 	}
}

void PI();
void PI()
{
	static float pi = 0;
	
	if (pi == 0)
		pi = (float)4.0*(float)atan(1.0);
	*(float *)--sp = pi;
}

void I_TO_F();
void I_TO_F()  /* n -- n */
{
	*(float *)&sp[0] = *(Integer *)&sp[0];
}

void F_TO_I();
void F_TO_I()  /* n -- n */
{
	if (*(float *)&sp[0] < 0.0) // round up or down
		sp[0] = (Cell)(ceil(*(float *)&sp[0]-0.5));
	else
		sp[0] = (Cell)(floor(*(float *)&sp[0]+0.5));
}

void FABS();
void FABS()  /* n -- n */
{
	*(float *)&sp[0] = (float)fabs(*(float *)&sp[0]);
}

void FEXP();
void FEXP()  /* n -- n */
{
	*(float *)&sp[0] = (float)exp(*(float *)&sp[0]);
}

void FLOG();
void FLOG()  /* n -- n */
{
	*(float *)&sp[0] = (float)log(*(float *)&sp[0]);
}

void FPOW();
void FPOW()  /* n m -- n */
{
	*(float *)&sp[1] = (float)pow(*(float *)&sp[1],*(float *)&sp[0]);
	sp++;	/* { DROP }*/
}

void FNEG();
void FNEG()  /* n -- n */
{
	*(float *)&sp[0] = -*(float *)&sp[0];
}

void F_FROM();
void F_FROM()  /* n m -- FLAG */
{
	if(*(float *)&sp[1]  >  *(float *)&sp[0] )
		*++sp = (Long)-1;
	else 
		*++sp = 0;
}

void FSQRT();
void FSQRT()  /* n -- n */
{
	*(float *)&sp[0] = (float)sqrt(*(float *)&sp[0]);
}

void F_PLUS();
void F_PLUS()  /* n m -- n */
{
	*(float *)&sp[1] = *(float *)&sp[0] + *(float *)&sp[1];
	sp++;	/* { DROP }*/
}

void F_MINUS();
void F_MINUS()  /* n m -- n */
{
	*(float *)&sp[1] = *(float *)&sp[1] - *(float *)&sp[0];
	sp++;	/* { DROP }*/
}

void F_STAR();
void F_STAR()  /* n m -- m */
{
	*(float *)&sp[1] = *(float *)&sp[1] * *(float *)&sp[0];
	sp++;	/* { DROP }*/
}

void F_SLASH();
void F_SLASH()  /* n m -- m */
{
	*(float *)&sp[1] = *(float *)&sp[1] / *(float *)&sp[0];
	sp++;	/* { DROP }*/
}

void FSIN();
void FSIN()  /* n --  n */
{
	*(float *)&sp[0] = (float)sin(*(float *)&sp[0]);
}

void FCOS();
void FCOS()  /* n --  n */
{
	*(float *)&sp[0] = (float)cos(*(float *)&sp[0]);
}

void FTAN();
void FTAN()  /* n --  n */
{
	*(float *)&sp[0] = (float)tan(*(float *)&sp[0]);
}

void FASIN();
void FASIN()  /* n --  n */
{
	*(float *)&sp[0] = (float)asin(*(float *)&sp[0]);
}

void FACOS();
void FACOS()  /* n --  n */
{
	*(float *)&sp[0] = (float)acos(*(float *)&sp[0]);
}

void FATAN();
void FATAN()  /* n --  n */
{
	*(float *)&sp[0] = (float)atan(*(float *)&sp[0]);
}

void FATAN_2();
void FATAN_2()  /* n m -- m */
{
	*(float *)&sp[1] = (float)atan2(*(float *)&sp[0],*(float *)&sp[1]);
	sp++;	/* { DROP }*/
}
